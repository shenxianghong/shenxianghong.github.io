---
title: "「 OpenFaaS 」快速开始"
excerpt: "OpenFaaS 概述"
cover: https://picsum.photos/0?sig=20230508
thumbnail: https://landscape.cncf.io/logos/open-faa-s.svg
date: 2023-05-08
toc: true
categories:
- Serverless
tag:
- OpenFaaS
---

<div align=center><img width="200" style="border: 0px" src="/gallery/openfaas/openfaas-logo.png"></div>

------

> based on **0.26.3**

# Serverless

在互联网软件产品的演进过程中，模型从 C/S（Client/Server），MVC（Model-View-Controller）等传统架构过渡到 SOA（Service-Oriented Architecture），最近几年又衍生出微服务架构，以及 Cloud Native。企业应用从单体架构，到服务化，再到更细粒度的微服务化，应用开发之初就是为了应对互联网特有的高并发、不间断的特性，需要很高的性能和可扩展性，人们对于软件开发的追求孜孜不倦，希望力求在软件开发的复杂度和效率之间达到一个平衡。

云改变了我们对操作系统的认知，原来一个系统的计算资源、存储和网络是可以分离配置的，而且还可以弹性扩展，但是长久以来，我们在开发应用时始终没有摆脱服务器的束缚（或者说认知），应用必须运行在无论是实体还是虚拟的服务器上，必须经过部署、配置、初始化才可以运行，还需要对服务器和应用进行监控和管理，还需要保证数据的安全性，这些云能够帮我们简化吗？**让我们只要关注自己代码的逻辑就好了，其它的东西让云帮我实现就好了。**

## Serverless 介绍

Serverless（无服务器架构）指的是由开发者实现的服务端逻辑运行在无状态的计算容器中，它由事件触发， 完全被第三方管理，其业务层面的状态则被开发者使用的数据库和存储资源所记录。

Serverless 是云原生技术发展的高级阶段，使开发者更聚焦在业务逻辑，而减少对基础架构的关注。

Serverless 架构是云的自然延伸，为了理解 Serverless，我们有必要回顾一下云计算的发展。

### IaaS

2006 年 AWS 推出EC2（Elastic Compute Cloud），作为第一代 IaaS（Infrastructure as a Service），用户可以通过 AWS 快速的申请到计算资源，并在上面部署自己的互联网服务。IaaS 从本质上讲是服务器租赁并提供基础设施外包服务。就比如我们用的水和电一样，我们不会自己去引入自来水和发电，而是直接从自来水公司和电网公司购入，并根据实际使用付费。

EC2 真正对 IT 的改变是硬件的虚拟化（更细粒度的虚拟化），而 EC2 给用户带来了以下五个好处：

- 降低劳动力成本：减少了企业本身雇佣 IT 人员的成本
- 降低风险：不用再像自己运维物理机那样，担心各种意外风险，EC2 有主机损坏，再申请一个就好了
- 降低基础设施成本：可以按小时、周、月或者年为周期租用 EC2
- 扩展性：不必过早的预期基础设施采购，因为通过云厂商可以很快的获取
- 节约时间成本：快速的获取资源开展业务实验

以上是 AWS 为代表的公有云 IaaS，还有使用 OpenStack 构建的私有云也能够提供 IaaS 能力。

### PaaS

PaaS（Platform as a Service）是构建在 IaaS 之上的一种平台服务，提供操作系统安装、监控和服务发现等功能，用户只需要部署自己的应用即可，最早的一代是 Heroku。Heroko 是商业的 PaaS，还有一个开源的 PaaS—— Cloud Foundry，用户可以基于它来构建私有 PaaS，如果同时使用公有云和私有云，如果能在两者之间构建一个统一的 PaaS，那就是“混合云“了。

在 PaaS 上最广泛使用的技术就要数 docker 了，因为使用容器可以很清晰的描述应用程序，并保证环境一致性。管理云上的容器，可以称为是 CaaS（Container as a Service），如 GCE（Google Container Engine）。也可以基于 Kubernetes 、Mesos 这类开源软件构件自己的 CaaS，不论是直接在 IaaS 构建还是基于 PaaS。

PaaS 是对软件的一个更高的抽象层次，已经接触到应用程序的运行环境本身，可以由开发者自定义，而不必接触更底层的操作系统。

<div align=center><img width="600" style="border: 0px" src="/gallery/serverless/overview.png"></div>

### 什么是 Serverless

<div align=center><img width="400" style="border: 0px" src="/gallery/serverless/architecture.png"></div>

Serverless 是由事件（event）驱动的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger），（比如 rpc 请求，定时器等）并上传。其余的工作（实例选择、 扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 Serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。

Serverless 相对于 Serverful，对业务用户强调 noserver（Serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。

Serverless 相比 Serverful，有以下 3 个改变：

1. 弱化了存储和计算之间的联系。服务的储存和计算被分开部署和收费，存储不再是服务本身的一部分，而是演变成了独立的云服务，这使得计算变得无状态化，更容易调度和扩缩容，同时也降低了数据丢失的风险
2. 代码的执行不再需要手动分配资源。不需要为服务的运行指定需要的资源（比如使用几台机器、多大的带宽、多大的磁盘等），只需要提供一份代码，剩下的交由 Serverless 平台去处理就行了。当前阶段的实现平台分配资源时还需要用户方提供一些策略，例如单个实例的规格和最大并发数，单实例的最大 CPU 使用率。理想的情况是通过某些学习算法来进行完全自动的自适应分配
3. 按使用量计费。Serverless 按照服务的使用量（调用次数、时长等）计费，而不是像传统的 Serverful 服务那样，按照使用的资源（ECS 实例、VM 的规格等）计费

### Serverless 的定义

Serverless 不如 IaaS 和 PaaS 那么好理解，因为它通常包含了两个领域 BaaS（Backend as a Service）和 FaaS（Function as a Service）。

**Bass**

BaaS（Backend as a Service）后端即服务，一般是一个个的 API 调用后端或别人已经实现好的程序逻辑，比如身份验证服务 Auth0，这些 BaaS 通常会用来管理数据，还有很多公有云上提供的我们常用的开源软件的商用服务，比如亚马逊的 RDS 可以替代我们自己部署的 MySQL，还有各种其它数据库和存储服务。

**Fass**

FaaS（Functions as a Service）函数即服务，FaaS 是无服务器计算的一种形式，当前使用最广泛的是 AWS 的 Lambada。

FaaS 本质上是一种事件驱动的由消息触发的服务，FaaS 供应商一般会集成各种同步和异步的事件源，通过订阅这些事件源，可以突发或者定期的触发函数运行。

传统的服务器端软件应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而 FaaS 是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以卸载掉。

**总结**

两者都为我们的计算资源提供了弹性的保障，BaaS 其实依然是服务外包，而 FaaS 使我们更加关注应用程序的逻辑，两者使我们不需要关注应用程序所在的服务器，但实际上服务器依然是客观存在的。

当我们将应用程序迁移到容器和虚拟机中时，其实对于应用程序本身的体系结构并没有多少改变，只不过有些流程和规定需要遵守，比如 12 因素应用守则，但是 Serverlss 对应用程序的体系结构来说就是一次颠覆了，通常我们需要考虑事件驱动模型，更加细化的部署形式，以及在 FaaS 组件之外保持状态的需求。

## Serverless 的使用场景

虽然 Serverless 的应用很广泛，但是其也有局限性，Serverless 比较适合以下场景：

- 异步的并发，组件可独立部署和扩展
- 应对突发或服务使用量不可预测（主要是为了节约成本，因为 Serverless 应用在不运行时不收费）
- 短暂、无状态的应用，对冷启动时间不敏感
- 需要快速开发迭代的业务（因为无需提前申请资源，因此可以加快业务上线速度）

Serverless 的使用场景示例如：

- ETL
- 机器学习及 AI 模型处理
- 图片处理
- IoT 传感器数据分析
- 流处理
- 聊天机器人

## Serverless 架构的优点

> 今天大多数公司在开发应用程序并将其部署在服务器上的时候，无论是选择公有云还是私有的数据中心，都需要提前了解究竟需要多少台服务器、多大容量的存储和数据库的功能等。并需要部署运行应用程序和依赖的软件到基础设施之上。假设我们不想在这些细节上花费精力，是否有一种简单的架构模型能够满足我们这种想法？这个答案已经存在，这就是今天软件架构世界中新鲜但是很热门的一个话题——Serverless（无服务器）架构。
>
> ——AWS 费良宏

**降低运营成本**

Serverless 是非常简单的外包解决方案。它可以让您委托服务提供商管理服务器、数据库和应用程序甚至逻辑，否则您就不得不自己来维护。由于这个服务使用者的数量会非常庞大，于是就会产生规模经济效应。在降低成本上包含了两个方面，即基础设施的成本和人员（运营/开发）的成本。

**降低开发成本**

IaaS 和 PaaS 存在的前提是，服务器和操作系统管理可以商品化。Serverless 作为另一种服务的结果是整个应用程序组件被商品化。

**扩展能力**

Serverless架构一个显而易见的优点即“横向扩展是完全自动的、有弹性的、且由服务提供者所管理”。从基本的基础设施方面受益最大的好处是，您只需支付您所需要的计算能力。

**更简单的管理**

Serverless架构明显比其他架构更简单。更少的组件，就意味着您的管理开销会更少。

**“绿色”的计算**

按照《福布斯》杂志的统计，在商业和企业数据中心的典型服务器仅提供 5%～15% 的平均最大处理能力的输出。这无疑是一种资源的巨大浪费。随着 Serverless 架构的出现，让服务提供商提供我们的计算能力最大限度满足实时需求。这将使我们更有效地利用计算资源。

在上面我们提到了使用 IaaS 给我们带来了五点好处，FaaS 当然也包括了这些好处，但是它给我们带来的最大的好处就是**多快好省**。减少从概念原型到实施的等待时间，比自己维护服务更省钱。

**降低人力成本**

不需要再自己维护服务器，操心服务器的各种性能指标和资源利用率，而是关心应用程序本身的状态和逻辑。而且serverless应用本身的部署也十分容易，我们只要上传基本的代码单元，例如 Javascript 或 Python 的源代码的 zip文件，以及基于 JVM 的语言的纯 JAR 文件。不需使用 Puppet、Chef、Ansible 或 Docker 来进行配置管理，降低了运维成本。同时，对于运维来说，也不再需要监控那些更底层的如磁盘使用量、CPU 使用率等底层和长期的指标信息，而是监控应用程序本身的度量，这将更加直观和有效。

在此看来有人可能会提出 “NoOps” 的说法，其实这是不存在的，只要有应用存在的一天就会有 Ops，只是人员的角色会有所转变，部署将变得更加自动化，监控将更加面向应用程序本身，更底层的运维依然需要专业的人员去做。

**降低风险**

对于组件越多越复杂的系统，出故障的风险就越大。我们使用 BaaS 或 FaaS 将它们外包出去，让专业人员来处理这些故障，有时候比我们自己来修复更可靠，利用专业人员的知识来降低停机的风险，缩短故障修复的时间，让我们的系统稳定性更高。

**减少资源开销**

我们在申请主机资源一般会评估一个峰值最大开销来申请资源，往往导致过度的配置，这意味着即使在主机闲置的状态下也要始终支付峰值容量的开销。对于某些应用来说这是不得已的做法，比如数据库这种很难扩展的应用，而对于普通应用这就显得不太合理了，虽然我们都觉得即使浪费了资源也比当峰值到来时应用程序因为资源不足而挂掉好。

解决这个问题最好的办法就是，不计划到底需要使用多少资源，而是根据实际需要来请求资源，当然前提必须是整个资源池是充足的（公有云显然更适合）。根据使用时间来付费，根据每次申请的计算资源来付费，让计费的粒度更小，将更有利于降低资源的开销。这是对应用程序本身的优化，例如让每次请求耗时更短，让每次消耗的资源更少将能够显著节省成本。

**增加缩放的灵活性**

以 AWS Lamba 为例，当平台接收到第一个触发函数的事件时，它将启动一个容器来运行你的代码。如果此时收到了新的事件，而第一个容器仍在处理上一个事件，平台将启动第二个代码实例来处理第二个事件。AWS lambad的这种自动的零管理水平缩放，将持续到有足够的代码实例来处理所有的工作负载。

但是，AWS 仍然只会向您收取代码的执行时间，无论它需要启动多少个容器实例要满足你的负载请求。例如，假设所有事件的总执行时间是相同的，在一个容器中按顺序调用 Lambda 100次与在100个不同容器中同时调用100次Lambda的成本是 一样的。当然 AWS Lambada 也不会无限制的扩展实例个数，如果有人对你发起了 DDos 攻击怎么办，那么不就会产生高昂的成本吗？AWS 是有默认限制的，默认执行 Lambada 函数最大并发数是1000。

**缩短创新周期**

小团队的开发人员正可以在几天之内从头开始开发应用程序并部署到生产。使用短而简单的函数和事件来粘合强大的驱动数据存储和服务的API。完成的应用程序具有高度可用性和可扩展性，利用率高，成本低，部署速度快。

以 Docker 为代表的容器技术仅仅是缩短了应用程序的迭代周期，而 Serverless 技术是直接缩短了创新周期，从概念到最小可行性部署的时间，让初级开发人员也能在很短的时间内完成以前通常要经验丰富的工程师才能完成的项目。

## Serverless 架构的缺点

我们知道没有十全十美的技术，在说了 Serverless 的那么多优势之后，我们再来探讨以下 Serverless 的劣势，或者说局限性和适用场景。

**状态管理**

要想实现自由的缩放，无状态是必须的，而对于有状态的服务，使用 Serverless 这就丧失了灵活性，有状态服务需要与存储交互就不可避免的增加了延迟和复杂性。

**延迟**

应用程序中不同组件的访问延迟是一个大问题，我们可以通过使用专有的网络协议、RPC 调用、数据格式来优化，或者是将实例放在同一个机架内或同一个主机实例上来优化以减少延迟。

而 Serverless 应用程序是高度分布式、低耦合的，这就意味着延迟将始终是一个问题，单纯使用 Serverless 的应用程序是不太现实的。

**本地测试**

Serverless 应用的本地测试困难是一个很棘手的问题。虽然可以在测试环境下使用各种数据库和消息队列来模拟生产环境，但是对于无服务应用的集成或者端到端测试尤其困难，很难在本地模拟应用程序的各种连接，并与性能和缩放的特性结合起来测试，并且 Serverless 应用本身也是分布式的，简单的将无数的 FaaS 和 BaaS 组件粘合起来也是有挑战性的。

***

# 简介

> Serverless Functions Made Simple

OpenFaaS 使开发人员可以轻松地将事件驱动（event-driven）的功能和微服务部署到 Kubernetes 中，而无需重复的模板代码。OpenFaaS 将代码或现有的二进制文件打包到 Docker 镜像中，使其具有自动缩放和服务指标的高度可扩展点。

**OpenFaaS 亮点**

- 支持丰富 UI 和一键安装，便于使用
- 借助[模板库](https://www.openfaas.com/blog/template-store/) 或 Dockerfile 以任何语言编写服务和函数
- 构建和发布代码至 Docker 镜像或其他 OCI 兼容格式的镜像中
- 易于移植，借助 [faas-netes](https://github.com/openfaas/faas-netes) 可在现有硬件或公有/私有云上运行
- 支持 YAML 格式的命令行工具 — [faas-cli](https://github.com/openfaas/faas-cli) ，用于模板化和定义函数
- 自动缩放，支持流量高峰扩容，并在空闲时缩减直至 0
- [版本丰富](https://www.openfaas.com/pricing/)，包含社区版、标准版和商业版

# 设计与架构

## Stack

无论是本地环境、自托管集群，还是带有托管服务（如 AWS Elastic Kubernetes Service (EKS)）的平台，部署 OpenFaaS 的推荐平台都是 **Kubernetes**。

<div align=center><img width="800" style="border: 0px" src="https://github.com/openfaas/faas/raw/master/docs/of-layer-overview.png"></div>

### CI / GitOps layer

OpenFaaS 既可以运行函数，也可以运行 HTTP 微服务。每个工作负载都构建到一个容器镜像中，并发布至镜像仓库。

在开发阶段，通常使用 faas-cli 手动操作完成，而在生产阶段，有几个常见的选择：

- 源代码控制管理（SCM）系统中内置的 CI 工具

  GitHub Actions 或 GitLab pipeline 是通过在 Job 中执行 faas-cli deploy 或 faas-cli up 构建和部署函数。部署是在 Job 完成后进行的，将变更推送到集群中。如果需要访问私有 VPC 或本地的集群，可以通过使用私有且安全的入口隧道来实现

- 使用 ArgoCD 和 Flux 等 GitOps 控制器

  GitOps 方式通常在新版本可用时立即持续部署 。部署是通过从特殊的配置库中获取预期状态来进行的

### Application Layer

- [OpenFaaS gateway](https://docs.openfaas.com/architecture/gateway/) 提供了一个 REST API，用于管理函数、记录指标和缩放
- [NATS](https://github.com/nats-io) 用于异步函数执行和排队
- Prometheus 提供指标并启用 Community Edition 和 OpenFaaS Pro 的自动缩放特性

使用 OpenFaaS Pro，可以通过 HTTP、Cron、AWS SQS 或 Apache Kafka 触发函数。

构成 OpenFaaS 的项目（Prometheus、Linux、OpenFaaS、NATS 和 Kubernetes）可以称为 [PLONK Stack](https://www.openfaas.com/blog/plonk-stack/)。 PLONK Stack 能够运行事件驱动（event-driven）的功能和传统的基于 HTTP 的微服务。

这些应用程序可以通过 Helm charts 或使用 ArgoCD、Flux 等 GitOps 控制器安装。

### Infrastructure Layer

- 函数的执行单元是 Pod，由 Containerd 或 Docker 管理
- 镜像仓库将每个函数作为不可变的制品保存，可以借助镜像仓库的 REST API、UI 或 CLI 将其部署到 OpenFaaS gateway
- Kubernetes 是允许函数跨平台，faasd 是小型安装的更简单替代方案

该 Layer 通常在探索和开发期间手动构建，在生产期间使用 Terraform 等工具构建。

### 工作流程

<div align=center><img width="800" style="border: 0px" src="https://github.com/openfaas/faas/blob/master/docs/of-workflow.png?raw=true"></div>

可以通过其 REST API、CLI 或 UI 访问 OpenFaas Gateway。所有服务或函数都会暴露一个默认路由，但自定义域也可以用于每个端点。

Prometheus 收集指标，这些指标可通过 OpenFaas Gateway 的 API 获得并用于自动缩放。

通过将函数的 URL 从同步的 /function/NAME 转变为异步的 /async-function/NAME，可以使用 NATS Streaming 在队列中运行调用。还可以传递一个可选的回调 URL。

faas-netes 是 OpenFaaS 最受欢迎的编排 Provider，但社区也提供了针对 Docker Swarm、Hashicorp Nomad、AWS Fargate/ECS 和 AWS Lambda 的 Provider。 Provider 使用 [faas-provider](https://github.com/openfaas/faas-provider) SDK 构建。

## Gateway

*https://github.com/openfaas/faas/tree/master/gateway*

API Gateway 为函数提供外部路由，并通过 Prometheus 收集云原生指标。此外，API Gateway 内置的 UI 可用于部署用户自定义的函数或来自 OpenFaaS Function Store 的函数，并调用。

API Gateway 将通过更改 Kubernetes API 中的服务副本计数来满足需求扩展功能。API Gateway 的 /system/alert endpoint 用于接收 AlertManager 生成的自定义告警。

**核心特点**

- 内置 UI
- 支持从 Function Store 部署函数或部署自定义函数
- 通过 Prometheus 检测
- 通过 AlertManager 和 Prometheus 自动缩放
- 缩放至 0
- 支持 REST API Swagger 文档

**以 Kubernetes 作为编排 Provider 的流程示例**

<div align=center><img width="800" style="border: 0px" src="https://docs.openfaas.com/images/of-conceptual-operator.png"></div>

## Watchdog

OpenFaaS watchdog 负责启动和监控 OpenFaaS 中的函数。通过使用 watchdog，任何二进制文件都可以成为一个函数。

watchdog 作为一个“初始化进程”，带有一个用 Golang 编写的嵌入式 HTTP 服务器，它可以支持并发请求、超时和健康检查。和 of-watchdog 类似，但非常适合流式的使用场景或需要在维护关键资源的情况，例如数据库连接、ML 模型或其他数据等请求之间。

### Classic watchdog

Classic watchdog 最初用于所有官方 OpenFaaS 模板，但 of-watchdog 现在更受青睐，并且在默认 [templates repository](https://github.com/openfaas/templates) 和[community template store](https://github.com/openfaas/store/blob/master/templates.json) 中存在用于通用编程语言的 watchdog 模板。*更多参考：https://github.com/openfaas/classic-watchdog/blob/master/README.md*

**watchdog 调用流程**

<div align=center><img width="600" style="border: 0px" src="https://camo.githubusercontent.com/61c169ab5cd01346bc3dc7a11edc1d218f0be3b4/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f4447536344626c554941416f34482d2e6a70673a6c61726765"></div>

### of-watchdog

> Reverse proxy for HTTP microservices and STDIO

of-watchdog 项目是对上述 Classic Watchdog 的补充（of-watchdog 适用于生产，是 openfaas GitHub 组织的一部分）。它于 2017 年 10 月启动，为 watchdog 和函数之间的通信提供了 STDIO 的替代方案。

**of-watchdog 组件的各种模式**

<div align=center><img width="800" style="border: 0px" src="https://docs.openfaas.com/architecture/watchdog-modes.png"></div>

of-watchdog 实现了一个监听 8080 端口的 HTTP 服务器，作为运行函数和微服务的反向代理。它可以独立使用，也可以作为 OpenFaaS 容器的入口点。

这个版本的 OpenFaaS 看门狗增加了对 HTTP 代理和 STDIO 的支持，具有内存重用和高速请求服务响应的特性，主要区别在于在调用之间保持函数进程处于待命状态（warm）的能力。Classic watchdog 为每个请求 fork 一个进程，提供最高级别的可移植性，在较新的版本启用了一种 HTTP 模式，在该模式下，可以复用进程以抵消 fork 带来的延迟。

它的目的不是要取代 Classic watchdog，而是为那些需要这些功能的人提供另一种选择。

## Faas Provider

faas-provider 提供函数的 CRUD API 以及调用功能。

faas-provider 是一个用 Go 编写的 SDK，它符合 OpenFaaS Provider 的 HTTP REST API。实现接口声明的 provider 应该与 OpenFaaS 工具链和生态系统兼容，包括 UI、CLI、Function Store 和 Template Store。

<div align=center><img width="800" style="border: 0px" src="https://docs.openfaas.com/images/providers/providers-conceptual-flow.png"></div>

每个 Provider 都实现以下行为：

- 函数（或微服务）的 CRUD
- 通过代理调用函数
- 函数缩放
- Secret 的 CRUD（可选）
- 日志流（可选）

### Kubernetes Provider

[faas-netes](https://github.com/openfaas/faas-netes) 是针对 Kubernetes 的官方 OpenFaaS Provider，默认内置在 Helm chart 中。

### faasd Provider

[faasd](https://github.com/openfaas/faasd) 是 OpenFaaS 的另一种思路实现，抛去了 Kubernetes 的成本和复杂性。可以在要求非常低的单个主机上运行，且具备快速、易于管理的特点。其底层是由 Containerd 、容器网络接口 （CNI） 以及来自 OpenFaaS 项目的核心组件构成。

### Docker Swarm Provider

[faas-swarm](https://github.com/openfaas/faas-swarm) 是针对 Docker Swarm 的官方 OpenFaaS Provider，现已弃用且不再维护。

### faas-memory Provider

faas-memory Provider 使用内存存储状态，仅用于测试目的和简单示例。

### 社区 Provider

参考实现：https://github.com/openfaas/faas/blob/master/community.md#openfaas-providers

## Log Provider

OpenFaaS 支持集成自定义的 Log Provider。

Log Provider 是一个 HTTP 服务器，对外暴露 /system/logs endpoint，该 endpoint 支持具有以下查询参数的 GET 请求：

- name - 函数名称（必需）
- instance - 容器名称（可选），允许从特定函数实例中请求日志
- since - 日志起始时间（可选）
- tail - 日志消息返回的最大数量，<=0 表示无限制
- follow - 允许用户请求日志流直至超时（启用时，服务器必须使用 HTTP 分块编码来发送日志的实时流）

### 配置

默认情况下，OpenFaaS Gateway 会将日志请求代理到函数 Provider。可以在 OpenFaaS Gateway 服务中设置 logs_provider_url 环境变量，OpenFaaS Gateway 会将日志请求代理到此 URL，实现 Log Provider 替换。

### faas-netes

[faas-netes ](https://github.com/openfaas/faas-netes)是 Kubernetes Provider 并从 Kubernetes API 查询日志。

### faasd

[faasd](https://github.com/openfaas/faasd) 从 journal 服务中查询日志，按函数和核心服务存储。

### openfaas-loki

[openfaas-loki](https://github.com/LucasRoesler/openfaas-loki) 是社区提供的 Log Provider，使用 [Grafana Loki](https://github.com/grafana/loki) 来收集和查询功能日志。

### 自定义的 Provider

借助 `github.com/openfaas/faas-provider/logs` 包提供的封装，可以构建自定义的 Log Provider HTTP 服务，参考示例：https://github.com/openfaas/faas-provider/tree/master/logs/example。
