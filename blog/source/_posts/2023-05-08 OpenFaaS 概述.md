---
title: "「 OpenFaaS 」OpenFaaS 概述"
excerpt: "OpenFaaS 概述"
cover: https://picsum.photos/0?sig=20230508
thumbnail: https://landscape.cncf.io/logos/open-faa-s.svg
date: 2023-05-08
toc: true
categories:
- Serverless
tag:
- OpenFaaS
---

<div align=center><img width="200" style="border: 0px" src="/gallery/openfaas/openfaas-logo.png"></div>

------

> based on **0.26.3**

# 简介

> Serverless Functions Made Simple

OpenFaaS 使开发人员可以轻松地将事件驱动（event-driven）的功能和微服务部署到 Kubernetes 中，而无需重复的模板代码。OpenFaaS 将代码或现有的二进制文件打包到 Docker 镜像中，使其具有自动缩放和服务指标的高度可扩展点。

**OpenFaaS 亮点**

- 支持丰富 UI 和一键安装，便于使用
- 借助[模板库](https://www.openfaas.com/blog/template-store/) 或 Dockerfile 以任何语言编写服务和函数
- 构建和发布代码至 Docker 镜像或其他 OCI 兼容格式的镜像中
- 易于移植，借助 [faas-netes](https://github.com/openfaas/faas-netes) 可在现有硬件或公有/私有云上运行
- 支持 YAML 格式的命令行工具 — [faas-cli](https://github.com/openfaas/faas-cli) ，用于模板化和定义函数
- 自动缩放，支持流量高峰扩容，并在空闲时缩减直至 0
- [版本丰富](https://www.openfaas.com/pricing/)，包含社区版、标准版和商业版

# Stack

无论是本地环境、自托管集群，还是带有托管服务（如 AWS Elastic Kubernetes Service (EKS)）的平台，部署 OpenFaaS 的推荐平台都是 **Kubernetes**。

<div align=center><img width="800" style="border: 0px" src="https://github.com/openfaas/faas/raw/master/docs/of-layer-overview.png"></div>

## CI / GitOps layer

OpenFaaS 既可以运行函数，也可以运行 HTTP 微服务。每个工作负载都构建到一个容器镜像中，并发布至镜像仓库。

在开发阶段，通常使用 faas-cli 手动操作完成，而在生产阶段，有几个常见的选择：

- 源代码控制管理（SCM）系统中内置的 CI 工具

  GitHub Actions 或 GitLab pipeline 是通过在 Job 中执行 faas-cli deploy 或 faas-cli up 构建和部署函数。部署是在 Job 完成后进行的，将变更推送到集群中。如果需要访问私有 VPC 或本地的集群，可以通过使用私有且安全的入口隧道来实现

- 使用 ArgoCD 和 Flux 等 GitOps 控制器

  GitOps 方式通常在新版本可用时立即持续部署 。部署是通过从特殊的配置库中获取预期状态来进行的

## Application Layer

- [OpenFaaS gateway](https://docs.openfaas.com/architecture/gateway/) 提供了一个 REST API，用于管理函数、记录指标和缩放
- [NATS](https://github.com/nats-io) 用于异步函数执行和排队
- Prometheus 提供指标并启用 Community Edition 和 OpenFaaS Pro 的自动缩放特性

使用 OpenFaaS Pro，可以通过 HTTP、Cron、AWS SQS 或 Apache Kafka 触发函数。

构成 OpenFaaS 的项目（Prometheus、Linux、OpenFaaS、NATS 和 Kubernetes）可以称为 [PLONK Stack](https://www.openfaas.com/blog/plonk-stack/)。 PLONK Stack 能够运行事件驱动（event-driven）的功能和传统的基于 HTTP 的微服务。

这些应用程序可以通过 Helm charts 或使用 ArgoCD、Flux 等 GitOps 控制器安装。

## Infrastructure Layer

- 函数的执行单元是 Pod，由 Containerd 或 Docker 管理
- 镜像仓库将每个函数作为不可变的制品保存，可以借助镜像仓库的 REST API、UI 或 CLI 将其部署到 OpenFaaS gateway
- Kubernetes 是允许函数跨平台，faasd 是小型安装的更简单替代方案

该 Layer 通常在探索和开发期间手动构建，在生产期间使用 Terraform 等工具构建。

## 工作流程

<div align=center><img width="800" style="border: 0px" src="https://github.com/openfaas/faas/blob/master/docs/of-workflow.png?raw=true"></div>

可以通过其 REST API、CLI 或 UI 访问 OpenFaas Gateway。所有服务或函数都会暴露一个默认路由，但自定义域也可以用于每个端点。

Prometheus 收集指标，这些指标可通过 OpenFaas Gateway 的 API 获得并用于自动缩放。

通过将函数的 URL 从同步的 /function/NAME 转变为异步的 /async-function/NAME，可以使用 NATS Streaming 在队列中运行调用。还可以传递一个可选的回调 URL。

faas-netes 是 OpenFaaS 最受欢迎的编排 Provider，但社区也提供了针对 Docker Swarm、Hashicorp Nomad、AWS Fargate/ECS 和 AWS Lambda 的 Provider。 Provider 使用 [faas-provider](https://github.com/openfaas/faas-provider) SDK 构建。

# Gateway

*https://github.com/openfaas/faas/tree/master/gateway*

API Gateway 为函数提供外部路由，并通过 Prometheus 收集云原生指标。此外，API Gateway 内置的 UI 可用于部署用户自定义的函数或来自 OpenFaaS Function Store 的函数，并调用。

API Gateway 将通过更改 Kubernetes API 中的服务副本计数来满足需求扩展功能。API Gateway 的 /system/alert endpoint 用于接收 AlertManager 生成的自定义告警。

**核心特点**

- 内置 UI
- 支持从 Function Store 部署函数或部署自定义函数
- 通过 Prometheus 检测
- 通过 AlertManager 和 Prometheus 自动缩放
- 缩放至 0
- 支持 REST API Swagger 文档

*以 Kubernetes 作为编排 Provider 的流程示例：*

<div align=center><img width="800" style="border: 0px" src="https://docs.openfaas.com/images/of-conceptual-operator.png"></div>

# Watchdog

OpenFaaS watchdog 负责启动和监控 OpenFaaS 中的函数。通过使用 watchdog，任何二进制文件都可以成为一个函数。

watchdog 作为一个“初始化进程”，带有一个用 Golang 编写的嵌入式 HTTP 服务器，它可以支持并发请求、超时和健康检查。和 of-watchdog 类似，但非常适合流式的使用场景或需要在维护关键资源的情况，例如数据库连接、ML 模型或其他数据等请求之间。

## Classic watchdog

Classic watchdog 最初用于所有官方 OpenFaaS 模板，但 of-watchdog 现在更受青睐，并且在默认 [templates repository](https://github.com/openfaas/templates) 和[community template store](https://github.com/openfaas/store/blob/master/templates.json) 中存在用于通用编程语言的 watchdog 模板。*更多参考：https://github.com/openfaas/classic-watchdog/blob/master/README.md*

*watchdog 调用流程：*

<div align=center><img width="800" style="border: 0px" src="https://camo.githubusercontent.com/61c169ab5cd01346bc3dc7a11edc1d218f0be3b4/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f4447536344626c554941416f34482d2e6a70673a6c61726765"></div>

## of-watchdog

> Reverse proxy for HTTP microservices and STDIO

of-watchdog 项目是对上述 Classic Watchdog 的补充（of-watchdog 适用于生产，是 openfaas GitHub 组织的一部分）。它于 2017 年 10 月启动，为 watchdog 和函数之间的通信提供了 STDIO 的替代方案。

*of-watchdog 组件的各种模式*

<div align=center><img width="800" style="border: 0px" src="https://docs.openfaas.com/architecture/watchdog-modes.png"></div>

of-watchdog 实现了一个监听 8080 端口的 HTTP 服务器，作为运行函数和微服务的反向代理。它可以独立使用，也可以作为 OpenFaaS 容器的入口点。

这个版本的 OpenFaaS 看门狗增加了对 HTTP 代理和 STDIO 的支持，具有内存重用和高速请求服务响应的特性，主要区别在于在调用之间保持函数进程处于待命状态（warm）的能力。Classic watchdog 为每个请求 fork 一个进程，提供最高级别的可移植性，在较新的版本启用了一种 HTTP 模式，在该模式下，可以复用进程以抵消 fork 带来的延迟。

它的目的不是要取代 Classic watchdog，而是为那些需要这些功能的人提供另一种选择。

# Faas Provider

faas-provider 提供函数的 CRUD API 以及调用功能。

faas-provider 是一个用 Go 编写的 SDK，它符合 OpenFaaS Provider 的 HTTP REST API。实现接口的 provider 应该与 OpenFaaS 工具链和生态系统兼容，包括 UI、CLI、Function Store 和 Template Store。
